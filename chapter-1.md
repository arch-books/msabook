# Глава 1: Что же такое микросервисы?

> В этой главе мы попытаемся разобраться в том, что такое микросервисная архитектура, какие преимущества она
> дает и о том, как и на основании чего стоит принимать решение о декомпозиции приложения на несколько
> отдельных deployment-unit

## Пытаемся разобраться

Виктор только что вернулся из командировки, в рамках которой он побывал на таких конференциях, как Highload и DDD Europe, на которых докладчики часто говорили о микросервисах, описывая их преимущества. Виктора заинтересовала эта тема, однако, как и многие хорошие архитекторы, он решил разобраться в ней подробнее. Он начал изучать тему, просматривая множество докладов и изучая классическую литературу, вроде книг [Сэма Ньюмена]() и [Криса Ричардсона](). По результатам своих исследований, Виктор пришел к выводу, что во многих источниках описываются следующие преимущества микросервисной архитектуры

- Она упрощает поставку ценности (деплой) в крупных приложениях.
- Сервисы получаются небольшими и простыми в обслуживании, с лучшей изоляцией от сбоев.
- Сервисы развертываются и масштабируются независимо друг от друга.
- Микросервисная архитектура обеспечивает автономность команд разработчиков.
- Она позволяет экспериментировать и внедрять новые технологии.

Так же он заметил, что к недостаткам монолитной архитектуры обычно относят следующие утверждения

- Медленная разработка
- Сложная поставка ценности клиентам (долгий деплой)
- Низкая надежность
- Плохая масштабируемость

Но во всем этом наборе утверждений было что-то, что смущало Виктора. И если с таким тезисом, как упрощенное внедрение технологий, Виктор был согласен, т.к. микросервисы действительно позволяют писать отдельные системы на других языках программирования или более современных версиях фреймворков, то с некоторыми другими, например, усложненным деплоем и замедлением разработки в монолитах, глядя на свой крупный проект, над которыми трудятся десятки команд, он не мог согласится.

Почему так ? Для ответа на этот вопрос стоит рассмотреть архитектуру монолитного приложения компании Dream Ride.

> [!WARNING]
>
> TODO: Добавить архитектурную схему модульного монолита

На этой схеме мы видим, что система компании Dream Ride представляет собой достаточно сложное приложение с множеством интеграций, которое состоит из нескольких отдельных deployment юнитов

- core-backend - система, реализующая все функциональные требования компании
- osrm-backend - система, реализующая логику роутинга и маршрутизации, построенная на основе open-source проекта [OSRM-Backend](https://github.com/Project-OSRM/osrm-backend)
- osrm-proxy - система, реализующая proxy сервис к `osrm-backend`, добавляющая такие возможности, как аутентификация, валидация и авторизация клиентов

Если говорить о монолите `core-backend`, то мы можем заметить, что Виктор, как и любой опытный архитектор, организовал очень хорошо структурированный монолит, который состоял из десятков независимых модулей.
При детальном рассмотрении архитектуры монолита, который построил Виктор, мы можем заметить несколько отличительных особенностей. Например, мы можем заметить, что монолит спроектирован по принципу plugin-based архитектуры и состоит из нескольких частей:

- Хост приложения, который является executable entrypoint (composition root), где происходит инициализация приложения и загрузка всех модулей
- Общие модули и библиотеки, которые представляют из себя транзитивные зависимости и могут быть использованы в любых других модулях
- Набор фиче-модулей, за разработку которых отвечают различные команды. Эти модули живут в отдельных репозиториях и подключаются в хост приложения посредством обычных библиотек. У каждого модуля свой репозиторий, релизный цикл и свой набор CI/CD пайплайнов

Давайте детальнее рассмотрим процесс релиза новой версии какого-либо модуля. Для этого нужно разобраться в структуре репозитория типичного фиче-модуля на примере модуля обработки заказов.

```
.
├── .github
│   └── workflows
│       ├── bump.yml
│       ├── build.yml
│       ├── test.yml
│       └── promote.yml
├── src
│   ├── OrdersApi
│   ├── OrdersApi.IpcApi
│   ├── OrdersApi.Server
│   ├── OrdersApi.Tests.Unit
│   └── OrdersApi.Tests.Functional
├── OrdersApi.sln
└── README.md
```

Здесь мы можем увидеть, что в корне репозитория лежит файл проекта, а сам репозиторий состоит из нескольких директорий верхнего уровня. Давайте рассмотрим его структуру подробнее.

**.github**

Эта папка содержит в себе набор воркфлоу и `Github` пайплайнов

**OrdersApi.sln**

Solution файл `.net` проекта, который необходим для запуска проекта во всех основных `.net` IDE

**src**

Эта директория содержит в себе несколько `.net` проектов разных типов

- **OrdersApi.IpcApi** - опциональный с точки зрения устройства модуля проект, который предоставляет публичные интерфейсы другим компонентам всего приложения.
- **OrdersApi** - проект, который содержит набор контроллеров, описание сущностей и бизнес-логику, которая реализует все необходимые функциональные требования модуля заказов. Так же этот проект реализует набор публичных интерфейсов, объявленных в проекте `OrdersApi.IpcApi`
- **OrdersApi.Server** - проект, являющийся пустым приложением `Asp .Net Core`, которое повторяет по смыслу хост монолитного приложения, о котором мы писали ранее. Это приложение необходимо для локального тестирования разработанного модуля и работает абсолютно так же, как и хост монолита: загружает модуль и подключает его к системе маршрутизации `Asp .Net Core`, инициализирует миграции и запускает все необходимые фоновые процессы, которые могут быть описаны в модуле.
- **OrdersApi.Tests.Unit** - проект юнит-тестов, написанный на `xunit`. Подключает в качестве зависимостей проект `OrdersApi` и покрывает юнит-тестами всю необходимую логику
- **OrdersApi.Tests.Functional** - проект функциональных тестов, так же использующий `xunit`. Он подключает к себе проект `OrdersApi.Server` и тестирует его набор эндпоинтов с настоящей базой данных. При этом, все внешние зависимости мокаются.

Теперь хочется сказать пару слов о том, как происходит разработка и поставка новых версий в production.

[TODO]

Что дает такая организация кода? Она позволяет конкретным командам разрабатывать независимые модули, тестируя только свой код. Это ограничивает размеры проектов, с которым приходится работать той или иной команде и не заставляет держать в голове весь набор модулей, который существует в проекте. Помимо этого,
